/**
 * Virtual Document Generator for Cross-Cell Linting
 *
 * Generates consolidated Python files from notebook cells that Pylance/pyright can analyze.
 * Maps cell boundaries to enable diagnostic translation back to individual cells.
 */

import * as vscode from 'vscode';
import * as path from 'path';
import * as crypto from 'crypto';
import { CellType } from '../types';

/**
 * Cell marker information for mapping diagnostics back to cells
 */
export interface CellMarker {
  /** Cell index in notebook */
  cellIndex: number;
  /** Line number where cell starts in virtual document */
  lineStart: number;
  /** Line number where cell ends in virtual document */
  lineEnd: number;
  /** Original cell URI */
  originalUri: string;
}

/**
 * Virtual document representation
 */
export interface VirtualDocument {
  /** Full Python content */
  content: string;
  /** Cell boundary markers */
  cellMarkers: CellMarker[];
  /** Virtual file path */
  filePath: string;
  /** Source notebook URI */
  notebookUri: string;
}

/**
 * Databricks preamble with type stubs for spark, dbutils, display
 */
const DATABRICKS_PREAMBLE = `"""
Databricks notebook virtual document for type checking.
Auto-generated by databricks-notebook extension.
"""
from typing import Any, Dict, List, Optional
from pyspark.sql import SparkSession, DataFrame, Column
from pyspark.sql.types import *

# Databricks runtime objects
spark: SparkSession
dbutils: Any  # TODO: Add detailed dbutils type stubs in Phase 2
display: Any  # Display function for tables/charts

`;

/**
 * Generates virtual Python documents from notebooks
 */
export class VirtualDocumentGenerator {
  private cacheDir: string;

  /**
   * Create a new VirtualDocumentGenerator
   * @param workspaceRoot - Workspace root directory
   */
  constructor(workspaceRoot: string) {
    this.cacheDir = path.join(workspaceRoot, '.databricks-cache');
  }

  /**
   * Generate virtual document from notebook
   * @param notebook - The notebook to analyze
   * @param includeDatabricksPreamble - Whether to include Databricks type stubs
   * @returns Virtual document representation
   */
  generateDocument(
    notebook: vscode.NotebookDocument,
    includeDatabricksPreamble: boolean = true
  ): VirtualDocument {
    const lines: string[] = [];
    const cellMarkers: CellMarker[] = [];
    let currentLine = 0;

    // Add Databricks preamble if enabled
    if (includeDatabricksPreamble) {
      lines.push(DATABRICKS_PREAMBLE);
      currentLine = DATABRICKS_PREAMBLE.split('\n').length;
    }

    // Process each cell
    for (let i = 0; i < notebook.cellCount; i++) {
      const cell = notebook.cellAt(i);

      // Only process code cells
      if (cell.kind !== vscode.NotebookCellKind.Code) {
        continue;
      }

      const cellContent = this.getCellContent(cell);

      // Skip empty cells
      if (!cellContent.trim()) {
        continue;
      }

      // Add cell marker comment
      const lineStart = currentLine;
      lines.push(`# CELL:${i}:${lineStart}`);
      currentLine++;

      // Add cell content
      const contentLines = cellContent.split('\n');
      lines.push(cellContent);
      currentLine += contentLines.length;

      // Add blank line between cells
      lines.push('');
      currentLine++;

      // Record cell marker
      cellMarkers.push({
        cellIndex: i,
        lineStart: lineStart + 1, // +1 to skip the marker comment itself
        lineEnd: currentLine - 2, // -2 to exclude the blank line
        originalUri: cell.document.uri.toString(),
      });
    }

    const content = lines.join('\n');
    const filePath = this.getVirtualFilePath(notebook.uri);

    return {
      content,
      cellMarkers,
      filePath,
      notebookUri: notebook.uri.toString(),
    };
  }

  /**
   * Get content for a cell, handling different cell types
   * @param cell - The cell to extract content from
   * @returns Python code or placeholder
   */
  private getCellContent(cell: vscode.NotebookCell): string {
    const metadata = cell.metadata as { databricksType?: CellType; magicCommand?: string };
    const type = metadata?.databricksType || 'code';

    switch (type) {
      case 'sql':
        return 'pass  # SQL cell';

      case 'markdown':
        return '';  // Skip markdown cells

      case 'scala':
      case 'r':
      case 'shell':
      case 'fs':
      case 'run':
      case 'pip':
        return 'pass  # Unsupported language or command';

      case 'code':
      default: {
        // Python code - strip magic command if present
        let content = cell.document.getText();

        // Strip %python magic command
        if (metadata?.magicCommand === '%python') {
          content = content.replace(/^%python\s*/m, '');
        }

        return content;
      }
    }
  }

  /**
   * Get virtual file path for a notebook
   * @param notebookUri - The notebook URI
   * @returns Path to virtual file
   */
  getVirtualFilePath(notebookUri: vscode.Uri): string {
    // Create hash of notebook URI for unique filename
    const hash = crypto.createHash('md5').update(notebookUri.toString()).digest('hex');
    return path.join(this.cacheDir, `notebook-${hash}.virtual.py`);
  }

  /**
   * Write virtual document to file system
   * @param doc - The virtual document to write
   */
  async writeVirtualDocument(doc: VirtualDocument): Promise<void> {
    try {
      // Ensure cache directory exists
      const cacheDirUri = vscode.Uri.file(this.cacheDir);
      try {
        await vscode.workspace.fs.stat(cacheDirUri);
      } catch {
        await vscode.workspace.fs.createDirectory(cacheDirUri);
      }

      // Write file
      const fileUri = vscode.Uri.file(doc.filePath);
      const content = new TextEncoder().encode(doc.content);
      await vscode.workspace.fs.writeFile(fileUri, content);

      console.debug(`[VirtualDocGenerator] Written virtual doc: ${doc.filePath}`);
    } catch (error) {
      console.error(`[VirtualDocGenerator] Failed to write virtual document:`, error);
      throw error;
    }
  }

  /**
   * Delete virtual document from file system
   * @param notebookUri - The notebook URI
   */
  async deleteVirtualDocument(notebookUri: vscode.Uri): Promise<void> {
    try {
      const filePath = this.getVirtualFilePath(notebookUri);
      const fileUri = vscode.Uri.file(filePath);
      await vscode.workspace.fs.delete(fileUri);
      console.debug(`[VirtualDocGenerator] Deleted virtual doc: ${filePath}`);
    } catch (error) {
      // Ignore errors if file doesn't exist
      console.debug(`[VirtualDocGenerator] Virtual doc not found (OK): ${error}`);
    }
  }

  /**
   * Get cache directory path
   * @returns Cache directory path
   */
  getCacheDir(): string {
    return this.cacheDir;
  }
}
